// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios9.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Half
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CoreGraphics.CGBase
import CoreGraphics
import Darwin
@_exported import Half
import Swift
import _Concurrency
import _StringProcessing
@_transparent public func acos(_ value: Half.Half) -> Half.Half {
    return Half(acos(Float(value)))
}
@_transparent public func acosh(_ value: Half.Half) -> Half.Half {
    return Half(acosh(Float(value)))
}
@_transparent public func asin(_ value: Half.Half) -> Half.Half {
    return Half(asin(Float(value)))
}
@_transparent public func asinh(_ value: Half.Half) -> Half.Half {
    return Half(asinh(Float(value)))
}
@_transparent public func atan(_ value: Half.Half) -> Half.Half {
    return Half(atan(Float(value)))
}
@_transparent public func atanh(_ value: Half.Half) -> Half.Half {
    return Half(atanh(Float(value)))
}
@_transparent public func cbrt(_ value: Half.Half) -> Half.Half {
    return Half(cbrt(Float(value)))
}
@_transparent public func cos(_ value: Half.Half) -> Half.Half {
    return Half(cos(Float(value)))
}
@_transparent public func cosh(_ value: Half.Half) -> Half.Half {
    return Half(cosh(Float(value)))
}
@_transparent public func erf(_ value: Half.Half) -> Half.Half {
    return Half(erf(Float(value)))
}
@_transparent public func erfc(_ value: Half.Half) -> Half.Half {
    return Half(erfc(Float(value)))
}
@_transparent public func exp(_ value: Half.Half) -> Half.Half {
    return Half(exp(Float(value)))
}
@_transparent public func exp2(_ value: Half.Half) -> Half.Half {
    return Half(exp2(Float(value)))
}
@_transparent public func expm1(_ value: Half.Half) -> Half.Half {
    return Half(expm1(Float(value)))
}
@_transparent public func log(_ value: Half.Half) -> Half.Half {
    return Half(log(Float(value)))
}
@_transparent public func log10(_ value: Half.Half) -> Half.Half {
    return Half(log10(Float(value)))
}
@_transparent public func log1p(_ value: Half.Half) -> Half.Half {
    return Half(log1p(Float(value)))
}
@_transparent public func log2(_ value: Half.Half) -> Half.Half {
    return Half(log2(Float(value)))
}
@_transparent public func logb(_ value: Half.Half) -> Half.Half {
    return Half(logb(Float(value)))
}
@_transparent public func nearbyint(_ value: Half.Half) -> Half.Half {
    return Half(nearbyint(Float(value)))
}
@_transparent public func rint(_ value: Half.Half) -> Half.Half {
    return Half(rint(Float(value)))
}
@_transparent public func sin(_ value: Half.Half) -> Half.Half {
    return Half(sin(Float(value)))
}
@_transparent public func sinh(_ value: Half.Half) -> Half.Half {
    return Half(sinh(Float(value)))
}
@_transparent public func tan(_ value: Half.Half) -> Half.Half {
    return Half(tan(Float(value)))
}
@_transparent public func tanh(_ value: Half.Half) -> Half.Half {
    return Half(tanh(Float(value)))
}
@_transparent public func tgamma(_ value: Half.Half) -> Half.Half {
    return Half(tgamma(Float(value)))
}
@_transparent public func atan2(_ lhs: Half.Half, _ rhs: Half.Half) -> Half.Half {
    return Half(atan2(Float(lhs), Float(rhs)))
}
@_transparent public func copysign(_ lhs: Half.Half, _ rhs: Half.Half) -> Half.Half {
    return Half(copysign(Float(lhs), Float(rhs)))
}
@_transparent public func fdim(_ lhs: Half.Half, _ rhs: Half.Half) -> Half.Half {
    return Half(fdim(Float(lhs), Float(rhs)))
}
@_transparent public func fmax(_ lhs: Half.Half, _ rhs: Half.Half) -> Half.Half {
    return Half(fmax(Float(lhs), Float(rhs)))
}
@_transparent public func fmin(_ lhs: Half.Half, _ rhs: Half.Half) -> Half.Half {
    return Half(fmin(Float(lhs), Float(rhs)))
}
@_transparent public func hypot(_ lhs: Half.Half, _ rhs: Half.Half) -> Half.Half {
    return Half(hypot(Float(lhs), Float(rhs)))
}
@_transparent public func nextafter(_ lhs: Half.Half, _ rhs: Half.Half) -> Half.Half {
    return Half(nextafter(Float(lhs), Float(rhs)))
}
@_transparent public func pow(_ lhs: Half.Half, _ rhs: Half.Half) -> Half.Half {
    return Half(pow(Float(lhs), Float(rhs)))
}
@_transparent public func lgamma(_ value: Half.Half) -> (Half.Half, Swift.Int) {
    let result = lgamma(Float(value))
    return (Half(result.0), result.1)
}
@_transparent public func remquo(_ lhs: Half.Half, _ rhs: Half.Half) -> (Half.Half, Swift.Int) {
    let result = remquo(Float(lhs), Float(rhs))
    return (Half(result.0), result.1)
}
@frozen public struct Half {
  public var _value: Half.half_t
  @_transparent public init() {
        self._value = _half_zero()
    }
  @_transparent public init(_ _value: Half.half_t) {
        self._value = _value
    }
}
extension Half.Half {
  @inlinable public var bitPattern: Swift.UInt16 {
    get {
        return _half_to_raw(_value)
    }
  }
  @inlinable public init(bitPattern: Swift.UInt16) {
        self._value = _half_from_raw(bitPattern)
    }
  @inlinable public init(nan payload: Swift.UInt16, signaling: Swift.Bool) {
        precondition(payload < (Half.quietNaNMask &>> 1), "NaN payload is not encodable.")

        var significand = payload
        significand |= Half.quietNaNMask &>> (signaling ? 1 : 0)

        self.init(sign: .plus, exponentBitPattern: Half.infinityExponent, significandBitPattern: significand)
    }
}
extension Half.Half : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Half.Half : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Half.Half : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Half.Half {
  @inlinable @inline(__always) internal static var significandMask: Swift.UInt16 {
    get {
        return 1 &<< UInt16(significandBitCount) - 1
    }
  }
  @inlinable @inline(__always) internal static var infinityExponent: Swift.UInt {
    get {
        return 1 &<< UInt(exponentBitCount) - 1
    }
  }
  @inlinable @inline(__always) internal static var exponentBias: Swift.UInt {
    get {
        return infinityExponent &>> 1
    }
  }
  @inlinable @inline(__always) internal static var quietNaNMask: Swift.UInt16 {
    get {
        return 1 &<< UInt16(significandBitCount - 1)
    }
  }
}
extension Half.Half : Swift.BinaryFloatingPoint {
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
        return 5
    }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
        return 10
    }
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
        return UInt(bitPattern &>> UInt16(Half.significandBitCount)) & Half.infinityExponent
    }
  }
  @inlinable public var significandBitPattern: Swift.UInt16 {
    get {
        return bitPattern & Half.significandMask
    }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt16) {
        let signBits: UInt16 = (sign == .minus ? 1 : 0) &<< (Half.exponentBitCount + Half.significandBitCount)
        let exponentBits = UInt16((exponentBitPattern & Half.infinityExponent) &<< Half.significandBitCount)
        let significandBits = significandBitPattern & Half.significandMask

        self.init(bitPattern: signBits | exponentBits | significandBits)
    }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            self = .nan
        } else {
            _value = _half_from(other)
        }
    }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            self = .nan
        } else {
            _value = _half_from(other)
        }
    }
  @inlinable @inline(__always) public init(_ other: CoreFoundation.CGFloat) {
        self.init(other.native)
    }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable @inline(__always) public init(_ other: Swift.Float16) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            self = .nan
        } else {
            self.init(bitPattern: other.bitPattern)
        }
    }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint {
        if let half = value as? Half {
            self.init(half._value)
        } else if value.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: value.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if value.isNaN {
            if value.isSignalingNaN {
                self = .signalingNaN
            } else {
                self = .nan
            }
        } else {
            self.init(_half_from(Float(value)))
        }
    }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint {
        self.init(value)

        if isInfinite || value.isInfinite {
            if value.isInfinite && (!isInfinite || sign != value.sign) {
                // If source is infinite but this isn't or this is but with a different sign
                return nil
            } else if isInfinite && !value.isInfinite {
                // If source isn't infinite but this is
                return nil
            }
        } else if isNaN || value.isNaN {
            if value.isNaN && (!isNaN || isSignalingNaN != value.isSignalingNaN) {
                // If source is NaN but this isn't or this is but one is signaling while the other isn't
                return nil
            } else if isNaN && !value.isNaN {
                // If source isn't NaN but this is
                return nil
            }
        } else if Source(self) != value {
            // If casting half back to source isn't equal to original source
            return nil
        }
    }
  @inlinable public var binade: Half.Half {
    get {
        guard isFinite else { return .nan }

        if isSubnormal {
            let bitPattern = (self * 0x1p10).bitPattern & (-Half.infinity).bitPattern
            return Half(bitPattern: bitPattern) * .ulpOfOne
        }

        return Half(bitPattern: bitPattern & (-Half.infinity).bitPattern)
    }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
        let trailingZeroBits = significandBitPattern.trailingZeroBitCount
        if isNormal {
            guard significandBitPattern != 0 else { return 0 }
            return Half.significandBitCount &- trailingZeroBits
        }
        if isSubnormal {
            let leadingZeroBits = significandBitPattern.leadingZeroBitCount
            return UInt16.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
        }
        return -1
    }
  }
  public typealias RawExponent = Swift.UInt
  public typealias RawSignificand = Swift.UInt16
}
extension Half.Half : Swift.ExpressibleByFloatLiteral {
  @_transparent public init(floatLiteral value: Swift.Float) {
        self.init(value)
    }
  public typealias FloatLiteralType = Swift.Float
}
extension Half.Half : Swift.FloatingPoint {
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Half.Half) {
        var result = significand
        if sign == .minus { result = -result }

        if significand.isFinite && !significand.isZero {
            var clamped = exponent
            let leastNormalExponent = 1 - Int(Half.exponentBias)
            let greatestFiniteExponent = Int(Half.exponentBias)

            if clamped < leastNormalExponent {
                clamped = max(clamped, 3 * leastNormalExponent)

                while clamped < leastNormalExponent {
                    result *= Half.leastNormalMagnitude
                    clamped -= leastNormalExponent
                }
            } else if clamped > greatestFiniteExponent {
                let step = Half(sign: .plus, exponentBitPattern: Half.infinityExponent - 1, significandBitPattern: 0)
                clamped = min(clamped, 3 * greatestFiniteExponent)

                while clamped > greatestFiniteExponent {
                    result *= step
                    clamped -= greatestFiniteExponent
                }
            }

            let scale = Half(sign: .plus, exponentBitPattern: UInt(Int(Half.exponentBias) + clamped), significandBitPattern: 0)
            result *= scale
        }

        self = result
    }
  @_transparent public init(_ value: Swift.Int) {
        _value = _half_from(value)
    }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
        if value.bitWidth <= MemoryLayout<Int>.size * 8 {
            if Source.isSigned {
                let asInt = Int(truncatingIfNeeded: value)
                self.init(_half_from(asInt))
            } else {
                let asUInt = UInt(truncatingIfNeeded: value)
                self.init(_half_from(asUInt))
            }
        } else {
            self.init(Float(value))
        }
    }
  @inlinable public var exponent: Swift.Int {
    get {
        if !isFinite { return .max }
        if isZero { return .min }

        let provisional = Int(exponentBitPattern) - Int(Half.exponentBias)
        if isNormal { return provisional }

        let shift = Half.significandBitCount - Int(significandBitPattern._binaryLogarithm())
        return provisional + 1 - shift
    }
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {

        return true
    }
  }
  @inlinable @inline(__always) public var isFinite: Swift.Bool {
    get {
        return exponentBitPattern < Half.infinityExponent
    }
  }
  @inlinable @inline(__always) public var isInfinite: Swift.Bool {
    get {
        return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable @inline(__always) public var isNaN: Swift.Bool {
    get {
        return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable @inline(__always) public var isNormal: Swift.Bool {
    get {
        return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable @inline(__always) public var isSignalingNaN: Swift.Bool {
    get {
        return isNaN && (significandBitPattern & Half.quietNaNMask) == 0
    }
  }
  @inlinable @inline(__always) public var isSubnormal: Swift.Bool {
    get {
        return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable @inline(__always) public var isZero: Swift.Bool {
    get {
        return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var nextUp: Half.Half {
    get {
        let next = self + 0


        if next < .infinity {
            let increment = Int16(bitPattern: next.bitPattern) &>> 15 | 1
            let bitPattern = next.bitPattern &+ UInt16(bitPattern: increment)
            return Half(bitPattern: bitPattern)
        }

        return next
    }
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
        let shift = Half.significandBitCount + Half.exponentBitCount
        // swiftlint:disable force_unwrapping
        return FloatingPointSign(rawValue: Int(bitPattern &>> UInt16(shift)))!
        // swiftlint:enable force_unwrapping
    }
  }
  @inlinable public var significand: Half.Half {
    get {
        if isNaN { return self }
        if isNormal {
            return Half(sign: .plus, exponentBitPattern: Half.exponentBias, significandBitPattern: significandBitPattern)
        }

        if isSubnormal {
            let shift = Half.significandBitCount - Int(significandBitPattern._binaryLogarithm())
            return Half(sign: .plus, exponentBitPattern: Half.exponentBias, significandBitPattern: significandBitPattern &<< shift)
        }

        return Half(sign: .plus, exponentBitPattern: exponentBitPattern, significandBitPattern: 0)
    }
  }
  @inlinable public var ulp: Half.Half {
    get {
        guard isFinite else { return .nan }
        if isNormal {
            let bitPattern = self.bitPattern & Half.infinity.bitPattern
            return Half(bitPattern: bitPattern) * .ulpOfOne
        }

        return .leastNormalMagnitude * .ulpOfOne
    }
  }
  @inlinable public static var greatestFiniteMagnitude: Half.Half {
    get {
        return Half(bitPattern: 0x7BFF)
    }
  }
  @inlinable public static var infinity: Half.Half {
    get {
        return Half(bitPattern: 0x7C00)
    }
  }
  @inlinable public static var leastNonzeroMagnitude: Half.Half {
    get {
        return Half(sign: .plus, exponentBitPattern: 0, significandBitPattern: 1)
    }
  }
  @inlinable public static var leastNormalMagnitude: Half.Half {
    get {
        return Half(sign: .plus, exponentBitPattern: 1, significandBitPattern: 0)
    }
  }
  @inlinable public static var nan: Half.Half {
    get {
        return Half(_half_nan())
    }
  }
  @inlinable public static var pi: Half.Half {
    get {
        return Half(_half_pi())
    }
  }
  @inlinable public static var signalingNaN: Half.Half {
    get {
        return Half(nan: 0, signaling: true)
    }
  }
  @inlinable public static var ulpOfOne: Half.Half {
    get {
        return Half(_half_epsilon())
    }
  }
  @_transparent public mutating func addProduct(_ lhs: Half.Half, _ rhs: Half.Half) {
        _value = _half_fma(_value, lhs._value, rhs._value)
    }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: Half.Half) {
        self = Half(Float(self).remainder(dividingBy: Float(other)))
    }
  @_transparent public mutating func formSquareRoot() {
        _value = _half_sqrt(_value)
    }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: Half.Half) {
        self = Half(Float(self).truncatingRemainder(dividingBy: Float(other)))
    }
  @_transparent public func isEqual(to other: Half.Half) -> Swift.Bool {
        return Bool(_half_equal(self._value, other._value))
    }
  @_transparent public func isLess(than other: Half.Half) -> Swift.Bool {
        return Bool(_half_lt(self._value, other._value))
    }
  @_transparent public func isLessThanOrEqualTo(_ other: Half.Half) -> Swift.Bool {
        return Bool(_half_lte(self._value, other._value))
    }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
        self = Half(Float(self).rounded(rule))
    }
  @_transparent public static func / (lhs: Half.Half, rhs: Half.Half) -> Half.Half {
        return Half(_half_div(lhs._value, rhs._value))
    }
  @_transparent public static func /= (lhs: inout Half.Half, rhs: Half.Half) {
        lhs._value = _half_div(lhs._value, rhs._value)
    }
  public typealias Exponent = Swift.Int
}
extension Half.Half : Swift.Hashable {
  @inlinable public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        self.hash(into: &hasher)
        return hasher.finalize()
    }
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        var value = self
        if isZero {
            value = 0 // to reconcile -0.0 and +0.0
        }

        hasher.combine(value.bitPattern)
    }
}
extension Half.Half : Swift.Strideable {
  @_transparent public func distance(to other: Half.Half) -> Half.Half {
        return other - self
    }
  @_transparent public func advanced(by amount: Half.Half) -> Half.Half {
        return self + amount
    }
  public typealias Stride = Half.Half
}
extension Half.Half : Swift.SignedNumeric {
  @_transparent public mutating func negate() {
        _value = _half_neg(_value)
    }
  @_transparent prefix public static func - (value: Half.Half) -> Half.Half {
        return Half(_half_neg(value._value))
    }
}
extension Half.Half : Swift.Numeric {
  @inlinable @inline(__always) public var magnitude: Half.Half {
    get {
        return Half(_half_abs(_value))
    }
  }
  @inlinable @inline(__always) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
        self.init(value)

        if isInfinite || isNaN || Source(self) != value {
            return nil
        }
    }
  @_transparent public static func * (lhs: Half.Half, rhs: Half.Half) -> Half.Half {
        return Half(_half_mul(lhs._value, rhs._value))
    }
  @_transparent public static func *= (lhs: inout Half.Half, rhs: Half.Half) {
        lhs._value = _half_mul(lhs._value, rhs._value)
    }
  public typealias Magnitude = Half.Half
}
extension Half.Half : Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(integerLiteral value: Swift.Int64) {
        self = Half(value)
    }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Half.Half : Swift.AdditiveArithmetic {
  @_transparent public static func + (lhs: Half.Half, rhs: Half.Half) -> Half.Half {
        return Half(_half_add(lhs._value, rhs._value))
    }
  @_transparent public static func += (lhs: inout Half.Half, rhs: Half.Half) {
        lhs._value = _half_add(lhs._value, rhs._value)
    }
  @_transparent public static func - (lhs: Half.Half, rhs: Half.Half) -> Half.Half {
        return Half(_half_sub(lhs._value, rhs._value))
    }
  @_transparent public static func -= (lhs: inout Half.Half, rhs: Half.Half) {
        lhs._value = _half_sub(lhs._value, rhs._value)
    }
}
extension Half.Half : Swift.CustomReflectable {
  @_transparent public var customMirror: Swift.Mirror {
    @_transparent get {
        return Mirror(reflecting: Float(self))
    }
  }
}
extension Half.Half : Swift.CustomPlaygroundDisplayConvertible {
  @_transparent public var playgroundDescription: Any {
    @_transparent get {
        return Float(self)
    }
  }
}
extension Half.Half : Swift.Codable {
  @_transparent public init(from decoder: Swift.Decoder) throws {
        let container = try decoder.singleValueContainer()
        let float = try container.decode(Float.self)

        guard float.isInfinite || float.isNaN || abs(float) <= Float(Half.greatestFiniteMagnitude) else {
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: container.codingPath, debugDescription: "Parsed number \(float) does not fit in \(type(of: self))."))
        }

        self.init(float)
    }
  @_transparent public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(Float(self))
    }
}
extension Half.Half : Swift.Sendable {}
